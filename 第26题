26.删除有序数组中的重复项
给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。
元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。

考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：
（1）更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。
（2）返回 k 。

示例 1：
输入：nums = [1,1,2]
输出：2
执行后：nums = [1,2,_(不考虑值是多少)]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。

示例 2：
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5
执行后：nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。

提示：
（1）1 <= nums.length <= 3 * 10^4
（2）-10^4 <= nums[i] <= 10^4
（3）nums 已按 升序 排列

题解：双指针
这道题目的要求是：对给定的有序数组nums删除重复元素，在删除重复元素之后，每个元素只出现一次，并返回新的长度，
上述操作必须通过原地修改数组的方法，使用 O(1)的空间复杂度完成。

由于给定的数组nums是有序的，因此对于任意i<j，如果nums[i]=nums[j]，则对任意i≤k≤j，必有nums[i]=nums[k]=nums[j]，
即相等的元素在数组中的下标一定是连续的。利用数组有序的特点，可以通过双指针的方法删除重复元素。

如果数组nums的长度为0，则数组不包含任何元素，因此返回0。

当数组nums的长度大于0时，数组中至少包含一个元素，在删除重复元素之后也至少剩下一个元素，因此nums[0]保持原状即可，从下标1开始删除重复元素。
定义两个指针fast和slow分别为快指针和慢指针，快指针表示遍历数组到达的下标位置，慢指针表示下一个不同元素要填入的下标位置，
初始时两个指针都指向下标1。

假设数组nums的长度为n。将快指针fast依次遍历从1到n-1的每个位置，对于每个位置，如果nums[fast]≠nums[fast−1]，
说明nums[fast]和之前的元素都不同，因此将nums[fast]的值复制到nums[slow]，然后将slow的值加1，即指向下一个位置。

遍历结束之后，从nums[0]到nums[slow−1]的每个元素都不相同且包含原数组中的每个不同的元素，因此新的长度即为slow，返回slow即可。

代码：
class Solution:
    def removeDuplicates(self, nums):
        if not nums:
            return 0
        
        n = len(nums)
        fast = slow = 1
        while fast < n:
            if nums[fast] != nums[fast - 1]:
                nums[slow] = nums[fast]
                slow += 1
            fast += 1
        
        return slow

